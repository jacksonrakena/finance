# Testing Conventions

## Framework Requirements

### Minitest + Fixtures Only
- **Always use Minitest and fixtures** for testing
- **NEVER use RSpec or factories**
- This choice maximizes familiarity and predictability for the open-source project

### Fixture Strategy
- **Keep fixtures to a minimum** - most models should have 2-3 fixtures maximum
- Fixtures should represent the "base cases" for that model
- **Create edge cases on the fly** within the context of the test where needed
- For tests requiring many fixture records, use Rails helpers (see `test/support/entries_test_helper.rb`)

## Testing Philosophy

### Write Minimal, Effective Tests
- **Use system tests sparingly** - they increase test suite completion time
- **Only write tests for critical and important code paths**
- **Write tests as you go**, when required
- **Practical approach**: Tests are effective when their presence significantly increases confidence in the codebase

### Examples of Necessary vs Unnecessary Tests

#### GOOD - Necessary Test
```ruby
# Testing critical domain business logic
test "syncs balances" do
  Holding::Syncer.any_instance.expects(:sync_holdings).returns([]).once

  @account.expects(:start_date).returns(2.days.ago.to_date)

  Balance::ForwardCalculator.any_instance.expects(:calculate).returns(
    [
      Balance.new(date: 1.day.ago.to_date, balance: 1000, cash_balance: 1000, currency: "USD"),
      Balance.new(date: Date.current, balance: 1000, cash_balance: 1000, currency: "USD")
    ]
  )

  assert_difference "@account.balances.count", 2 do
    Balance::Syncer.new(@account, strategy: :forward).sync_balances
  end
end
```

#### BAD - Unnecessary Test
```ruby
# Simply testing ActiveRecord's functionality
test "saves balance" do 
  balance_record = Balance.new(balance: 100, currency: "USD")

  assert balance_record.save
end
```

## Test Boundaries

### Commands vs Queries
Distinguish between commands and query methods:
- **Test output of query methods**
- **Test that commands were called with correct params**

#### Example of Correct Boundary Testing
```ruby
class ExampleClass
  def do_something
    result = 2 + 2
    CustomEventProcessor.process_result(result)
    result
  end
end

class ExampleClassTest < ActiveSupport::TestCase
  test "boundaries are tested correctly" do 
    # GOOD - testing that the command was received, not internal implementation
    # The actual tests for CustomEventProcessor belong in a different test suite!
    CustomEventProcessor.expects(:process_result).with(4).once

    result = ExampleClass.new.do_something

    # GOOD - testing the implementation of ExampleClass inside its own test suite
    assert_equal 4, result
  end
end
```

### Key Boundary Rules
- **Never test implementation details** of one class in another class's test suite
- Focus on the contract/interface, not internal mechanics
- Each class should be tested in isolation

## Stubs and Mocks

### Use Mocha Gem
- Always use the `mocha` gem for stubbing and mocking
- **Prefer `OpenStruct`** when creating mock instances
- For complex cases, create a mock class
- **Only mock what's necessary** - if you're not testing return values, don't mock a return value

### Mock Examples
```ruby
# Simple mock with OpenStruct
mock_user = OpenStruct.new(id: 1, name: "Test User")

# Expectation without return value (command)
SomeService.expects(:process).with(expected_params).once

# Expectation with return value (query)
SomeService.expects(:calculate).returns(42).once
```

## Test Organization

### File Structure
- Follow Rails conventions for test file placement
- Use `test/support/` for shared test helpers
- Keep test-specific fixtures in `test/fixtures/`
- Use descriptive test method names that explain the scenario

### Test Helpers
- Create helpers for complex setup scenarios
- Share common assertions across test files
- Use helpers to create test data when fixtures aren't sufficient

This testing approach ensures we maintain high confidence in critical code paths while keeping the test suite fast and maintainable.