# Component Development Guidelines

## ViewComponent Architecture

### Component Scope and Usage
- Components in this directory should **only be used within their own component templates**
- **Do not use component controllers** outside of their specific component
- For cross-application functionality, use global controllers in `app/javascript/controllers/`

### When to Create Components
Create ViewComponents when you need:
- **Complex logic or styling patterns**
- **Reusable elements** across multiple views/contexts
- **Structured styling** with variants/sizes (buttons, badges, cards)
- **Interactive behavior** requiring Stimulus controllers
- **Configurable slots** or complex APIs
- **Accessibility features** or ARIA support

### Component Structure
Follow the established patterns in existing components:
- Component class with clear initialization parameters
- Slots for flexible content areas
- Variants for different styling options
- Private methods for computed properties
- Stimulus controller integration when needed

## Design System Integration

### Use Design Tokens
- Always reference `app/assets/tailwind/maybe-design-system.css`
- Use functional tokens over raw Tailwind classes:
  - `text-primary` instead of `text-white`
  - `bg-container` instead of `bg-white`
  - `border border-primary` instead of `border border-gray-200`

### Component Styling
- Define variant-based styling within the component class
- Use computed CSS classes based on component state
- Keep styling logic in Ruby, not in templates
- Follow existing component patterns for consistency

## Stimulus Integration

### Component-Specific Controllers
- Stimulus controllers in component directories are **component-scoped**
- Use declarative approach in component templates
- Pass data via `data-*-value` attributes
- Keep controllers focused on DOM interaction only

### Example Component with Stimulus
```ruby
class ToggleComponent < ApplicationComponent
  def initialize(initial_state: :hidden, **options)
    @initial_state = initial_state
    @options = options
  end

  private

  attr_reader :initial_state, :options

  def controller_data
    {
      controller: "toggle",
      toggle_initial_state_value: initial_state
    }
  end

  def content_classes
    classes = ["transition-all"]
    classes << "hidden" if initial_state == :hidden
    classes.join(" ")
  end
end
```

```erb
<div data-<%= controller_data %>>
  <button data-action="click->toggle#toggle" data-toggle-target="button">
    <%= initial_state == :hidden ? "Show" : "Hide" %>
  </button>
  <div data-toggle-target="content" class="<%= content_classes %>">
    <%= content %>
  </div>
</div>
```

## Component Best Practices

### API Design
- **Clear initialization parameters** with sensible defaults
- **Keyword arguments** for better readability
- **Slots for flexible content** areas
- **Variants for styling options**
- **Boolean flags for behavior** modifications

### Naming Conventions
- Use `ComponentName` suffix (e.g., `ButtonComponent`, `DialogComponent`)
- Descriptive slot names (`with_header`, `with_body`, `with_footer`)
- Clear variant names (`primary`, `secondary`, `danger`)

### Documentation
- Document component APIs with clear examples
- Show common usage patterns
- Explain available slots and variants
- Include accessibility considerations

### Testing
- Test component rendering with different configurations
- Test slot content rendering
- Test variant styling application
- Test Stimulus controller integration if applicable

This approach ensures components remain reusable, maintainable, and consistent with the overall design system while providing clear boundaries for their usage.